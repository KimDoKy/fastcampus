# 논리연산자 문제 풀이

### 연산 후 각 연산의 결과를 10진수 및 16진수로 변환해 보세요.

####1. 1011 1101 & 0111 1010   

**풀이 :**  
1011 1101에서 가운데 띄어쓰기가 있는 이유는 단순히 4비트씩 끊어서 편하게 보기 위함이다. 

<pre>
      144          1011 1101
     + 55        & 0111 1010
     ────        ───────────
      199          0011 1000
</pre>

`+`연산에서 4와 5가 더해지는 것처럼 `&`연산도 단순하게 각 자리수끼리 연산을 하면 된다.  
`&`연산은 `A & B`일 때 A와 B모두 1일 때만 연산결과가 1이 된다. 

**답 : 0011 1000**  

---

####2. 1011 1101 | 0111 1010  

**풀이 :**  
<pre>
                   1011 1101
                 | 0111 1010
                 ───────────
                   1111 1111
</pre>
1번 문제와 마찬가지로 각 자리수(비트)끼리 `|`연산을 한다.  
`A | B`는 A **"또는"** B가 1이라면, 즉 둘 중 하나라도 1이라면  
연산결과가 1이 된다. 

**답 : 1111 1111**   

---

####3. 0xAF & 0x8C  

**풀이 :**  
`0x`는 16진수(Hexadecimal)를 의미한다.   
즉, 16진수인 AF와 8C간 `&`연산을 하라는 의미이다.   

`&`연산을 하기 위해 두 수를 각각 2진수로 변환한다.  
16진수의 각 자리는 2진수의 4자리와 동일하다.  
따라서, 0xAF는 A가 1010이고 F가 1111이기 때문에   
1010 1111로 변환된다.   
마찬가지로 0x8C는 1000 1100으로 변환된다.  

2진수로 변환된 값을 가지고 `&`연산을 수행하면, 
<pre>
                   1010 1111
                 & 1000 1100
                 ───────────
                   1000 1100
</pre>
1000 1100이 된다.   
처음 표기가 16진수로 되어있었기 때문에 이 숫자를 다시 16진수로 변환하면,  
0x8C가 된다.  

**답 : 0x8C**  

---

####4. 25(10) | 12(10)

**풀이 :**  
3번과 마찬가지로 10진수를 2진수로 변환한다.  
25 = 16 + 8 + 1 = 11001   
12 = 8 + 4 = 1100  

<pre>
                   11001
                 | 01100   (가독성을 위해 맨 앞자리에 0을 추가한다.)
                 ───────
                   11101
</pre>
2진수를 통한 `|` 연산결과는 11101이고   
다시 10진수로 변환하면   
11101 = 16 + 8 + 4 + 1 = 29이다.  


**답 : 29**  

---

####5. 25(10) & 12(10)

**풀이 :**  
4번 문제에서 `|`연산이 `&`연산으로만 바뀐 형태다.  
<pre>
                   11001
                 & 01100   
                 ───────
                   01000
</pre>
연산결과는 1000이므로 10진수로 변환하면 8이다.   

**답 : 8**  

---

####6. ~ 1010 0011

**풀이 :**  
`~`연산은 `NOT`을 의미한다.  
비트연산에서는 0과 1밖에 표현할 수 없기 때문에   
"~1 : 1이 아니다"의 의미는 0이다와 동일하다.   
<pre>
                ~ 1010 0011
                ────────────
                  0101 1100
</pre>
각 비트에 `~`연산을 해주면 연산결과는 0101 1100이 된다.   

**답 : 0101 1100**  

---

####7. ~ A8(16)

**풀이 :**  
16진수로 표현이 되었기 때문에 비트연산을 위해서 2진수로 변환한다.  
A = 1010, 8 = 1000    
~ A8 = 1010 1000   
<pre>
                ~ 1010 1000
                ────────────
                  0101 0111
</pre>
각 비트에 `~`연산을 해주면 연산결과는 0101 0111이 된다.  
다시 16진수로 변환하면 0x57이 된다.   


**답 : 0x57**  

---
