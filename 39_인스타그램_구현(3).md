### 게시물 보여주기
1. 리스트 페이지
2. 세부 페이지

### #1. 리스트페이지

> post/views.py

```python
def post_list(request):
    posts = Post.objects.all()
    form = CommentForm()

    context = {
        'posts': posts,
        'form': form,
    }

    return render(request, 'post/post_list.html', context)
```
post_list에 대한 view를 정의한다.

모든 post를 보여주기 위해 전체 데이터를 posts에 담는다. form은 post/forms.py에서 정의한 CommentForm 형태의 객체이다. form은 잠시후에 한꺼번에 다룰 예정이다. context에 전체 post와 form 정보를 담아 view와 연동될 템플릿과 렌더링하여 반환한다.

post_list.html에서는 context로 넘겨받은 정보를 사용할 수 있다. 

> templates/post/post_list.html

```html
<h1>post_list</h1>

{% for post in posts %}
<div style="border: solid red 1px">
    <h3>author : {{ post.author.username }}</h3>

    <img src="{{ MEDIA_URL }}{{ post.photo }}" alt="">
    <h3>좋아요 {{ post.like_users.count }}개</h3>
    <h3>{{ post.content|linebreaksbr|truncatechars:100 }}</h3>
    {% if post.comment_set.all %}
        {% for comment in post.comment_set.all %}
            <p>{{ comment.author }} : {{ comment.content }}</p>
        {% endfor %}
    {% else %}
        <p>No comments</p>
    {% endif %}

    <form action="{% url 'post:comment_add' post_id=post.id %}" method="post">{% csrf_token %}
        <div>{{ form.content }}</div>
        <!--<input type="text" name="content">-->
        <button type="submit" name="list" value="{{ post.id }}">Write Comment</button>
    </form>

</div>
{% endfor %}
```
전체 코드는 for 반복문 안에 들어있다. 리스트의 각 아이템은 작성자, 이미지, 좋아요 수, 내용, 댓글(for 반복) 등을 보여주고 form을 통해 댓글입력창을 제공한다. 

MEDIA_URL은 각 app이 사용할 미디어파일들의 경로를 불러온다. MEDIA_URL을 세팅하기 위해 settings.py에서 3가지를 설정해준다. 

```python
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')	# 상단에 추가
'django.template.context_processors.media',	# TEMPLATES > OPTIONS > context_processors에 추가
MEDIA_URL = '/media/'	# 하단에 추가
```
post.photo는 ImageField에서 이미지를 업로드할 때 경로가 저장된다. post앱에서 추가한 것이기 때문에 post/photo.jpg 형식으로 저장된다. MEDIA_URL이 '/media/'이고 이미지 경로와 합쳐진다. {{ MEDIA_URL }}{{ post.photo }}가 '/media/post/photo.jpg'형태로 변환되는 것이다.   
![image1](https://s2.postimg.org/9iv3961d5/0215_1.png)  
위의 사진에서 보이는 경로에 저장되고 호출된다. 

`post.content|linebreaksbr|truncatechars:100`는 post의 content를 출력하는데 뒤의 옵션을 통해 결과값을 정제한다. 텍스트에서 줄바꿈이 발생하면 linebreaksbr가 이를 처리해준다. 설정하지 않으면 줄바꿈 없이 텍스트가 출력된다. truncatechar은 너무 많은 텍스트가 출력되는 것을 제한한다. 100자 이후로는 ... 형태로 마무리된다. 

`{% if post.comment_set.all %}`, post에 달린 댓글을 역참조하여 사용한다. 그리고 for문을 이용하여 모든 댓글을 출력한다. 



### #2 세부페이지

> post/views.py

```python
def post_detail(request, post_id):
    post = Post.objects.get(pk=post_id)
    form = CommentForm()
    context = {
        'post': post,
        'form': form,
    }
    return render(request, 'post/post_detail.html', context)
```
구동방식은 post_list 뷰와 거의 동일하다. 한가지 다른 점은 post_list는 전체리스트를 보여주기 때문에 쿼리셋이 Post.objects.all()인 반면 post_detail은 하나의 포스트만 다루기 때문에 post_id를 이용하여 pk에 접근한다. 

> templates/post/post_detail.html

```html
<div>{{ post.created_date }}</div>
<img src="{{ MEDIA_URL }}{{ post.photo }}" alt="">
<h3>좋아요 {{ post.like_users.count }}개</h3>
<h3>{{ post.content|linebreaksbr }}</h3>

<div>
    <p>Comments</p>

    {% if post.comment_set.all %}
    <ul style="list-style-type:none">
            {% for comment in post.comment_set.all %}
            <li>{{comment.author}} : {{ comment.content}}</li>
            {% endfor %}
        {% else %}
        <p>No comments</p>
    </ul>
    {% endif %}

    <!--action에 아무값도 넣지 않으면 현재 페이지로 request를 보낸다-->
    <form action="{% url 'post:comment_add' post_id=post.id%}" method="post">{% csrf_token %}
        <div>{{ form.content }}</div>
        <!--<input type="text" name="content">-->
        <button type="submit">Write Comment</button>
    </form>
</div>
```
포스트의 날짜, 이미지(위와 동일), 좋아요수, 내용, 댓글 등 모든 정보가 리스트에 출력되었던 것과 동일하다. 가장 큰 차이점은 하나의 포스트에 대해서 작업하기 때문에 전체 내용을 출력하는데 있어서 반복하지 않는다. (댓글만 반복)


### 댓글 추가하기 (form 다루기)
리스트페이지와 세부페이지에서 각각 댓글을 추가하면 원래 있던 페이지로 돌아가야 한다. 먼저 세부페이지에서 어떻게 댓글을 추가하는지









```
























```


