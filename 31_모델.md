# 모델

- 장고의 모델은 django.db.models.Model을 상속받는다.  
- 모델의 각 속성은 Database field를 나타낸다. 
- 장고가 자동으로 DB에 접근할 수 있도록 해준다. 

모델 하나는 클래스 하나다. 

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```
여기서,  
모델은 Person이고  
필드는 first_name, last_name  

위의 모델이 생성되면 SQL은 다음과 같이 구성된다.  
```sql
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

**notes**

> id는 기본적으로 유니크한 속성을 가진다. 생성시 이전 id보다 +1이 된 값을 (auto increment) 부여한다. 오버라이드를 하여 다른 행동을 부여할 수 있다. 

-

### 필드
모델의 필드들은 필드 클래스의 인스턴스들이다.  
데이터타입을 결정해주고, 관리자 페이지의 폼을 자동으로 구성해준다.  

**자주 쓰는 옵션**   
부가적인 옵션이므로 필수사항은 아니다.  

- null : True이면 초기값이 아무 값이 없을 때 null이 저장된다.  
- blank : True이면 빈 값을 허용한다. False면 반드시 값을 입력해야한다.  
- choices : 리스트형 객체가 있을 때 그 중 선택할 수 있는 옵션을 부여한다.  

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```
```python
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

p.shirt_size 는 'L'이라는 값을 가지고 있고 이 값이 SHIRT_SIZES의 첫 element와 매칭되고 두번째 element의 값을 가지고 온다. 이런 접근이 가능한 것은 shirt_size에 choices라는 옵션이 부여됐기 때문이다. 

- default : 값이 부여되지 않았을 경우 초기값을 설정해준다.  
- help_text : 관리자페이지에서 필드값의 추가설명을 설정한다.  
- primary_key : True로 설정하면 해당 model의 primary_key가 된다. 읽기 전용의 성격을 지니고 있기 때문에 값의 수정이 불가능하다. 객체를 통한 값의 수정을 할 경우 기존의 객체는 저장되고 새로운 primary_key 값을 가진 데이터가 생성된다. 
- unique : 중복되지 않는 값을 가진다.  

-

### Automatic primary key fields

```python
id = models.AutoField(primary_key=True)
```
장고는 기본적으로 id 값을 AutoField에 primary_key 옵션을 부여한다. id는 autoincrement 속성을 가지게 되고 1씩 증가하는 유니크한 값을 가진다.  

### Verbose field names

verbose_name
```
first_name = models.CharField("person's first name", max_length=30)
```
필드값의 첫 인자값으로 "person's first name"을 주게 되면 verbose_name 역할을 한다. 
```
first_name = models.CharField(max_length=30)
```
아무값도 주지 않으면 'first_name'이 verbose_name이다.  
```
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
)
```
ForeignKey, ManyToManyField, OneToOneField 등은 첫 인자로 관계가 맺어지는 클래스명을 받아야 하기 때문에 verbose_name을 명시적으로 설정해준다. 

-

### Relationships

**Many-to-one relationships**  

```python
class Manufacturer(models.Model):
    title = models.CharField(max_length=100)

    def __str__(self):
        return self.title


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer)
    title = models.CharField(max_length=100)

    def __str__(self):
        return '{} {}'.format(
            self.manufacturer.title,
            self.title
        )
```
Car는 ForeignKey 필드값의 참조를 Manufacturer로 한다. Many to One이 Car to Manufacturer이다. 여러 대의 자동차는 하나의 제조사 정보를 가진다.

> Manufacturer모델을 참조하는 ForeignKey의 이름은 manufacturer로 한다. 소문자로 처리해주도록!!
>
> Car가 Manufacturer을 참조한다. Car가 Manufacturer보다 코드라인의 위쪽에 위치하고 있으면 참조에러가 발생한다. 

![manytoone](https://s23.postimg.org/iw4zl4g4b/pic10.png)  
Car모델을 이용하여 만든 데이터베이스를 보면 id, title, manufacturer_id가 있다. id는 자동적으로 생성되는 요소이고 title은 CharField로 만들었다. manufacturer_id는 ForeignKey로 Manufacturer를 참조하면서 생성된다. car의 데이터가 어떤 manufacturer을 참조하는지 나타낸다.  

#### 자기자신을 참조하는 many-to-one

Person이라는 모델이 있을 때, student와 instructor는 Person의 요소를 가져야 한다. 한 명의 강사에게 여러명의 학생이 있을 수 있기 때문에 instructor는 ForeignKey를 지정하면서 자기자신인 Person을 참조하도록 한다. 

```python
class Person(models.Model):
    instructor = models.ForeignKey(
        'self',
        verbose_name='담당 강사',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='student_set',    
    )
    # 역참조 이름, 기본적으로는 person_set
```
Foreign Key의 참조 모델이 자기자신('self')일 때 역참조는 person_set 형식으로 찾아간다. 하지만 다른 Foreign Key도 self로 참조할 때는 둘 다 person_set이라는 이름을 쓰려고 하기 때문에 에러가 발생한다.  
related_name='student_set'으로 설정해서 person_set대신 student_set이라는 이름으로 접근할 수 있게 된다. 

-

**Many-to-many relationships**  

기본구조 

```python
class Topping(models.Model):
    title = models.CharField(max_length=30)

    def __str__(self):
        return self.title

class Pizza(models.Model):
    title = models.CharField(max_length=100)
    # 포함관계에서 상위 요소에 해당하는 클래스에 ManyToMany를 선언한다.
    # 복수니까 복수형으로 이름 지정!!
    toppings = models.ManyToManyField(Topping)

    def __str__(self):
        return '{}, Topping : {}'.format(
            self.title,
            ', '.join([topping.title for topping in self.toppings.all()])
        )
```
피자는 여러 토핑을 가질 수 있고, 토핑은 여러 피자위에 올라갈 수 있다. 따라서, Many to Many 관계라고 할 수 있다. 상식적으로 생각해보면 피자가 많은 토핑을 가진다 라고 표현하기 때문에 Pizza 모델에 toppings를 추가한다. 

```python
#전체 객체와 요소 출력
Pizza.objects.all()
<QuerySet [<Pizza: cheese pizza, Topping : ham, pimang>, <Pizza: supreme pizza, Topping : >, <Pizza: bulgogi pizza, Topping : bulgogi>]>

------------------------------------------------------

#이름이 title인 속성의 실제 값들만 출력
Pizza.objects.values_list('title')
<QuerySet [('cheese pizza',), ('supreme pizza',), ('bulgogi pizza',)]>

------------------------------------------------------

#위의 내용을 리스트 형태로 출력
Pizza.objects.values_list('title', flat=True)
<QuerySet ['cheese pizza', 'supreme pizza', 'bulgogi pizza']>

------------------------------------------------------

#리스트 객체를 문자열로 만들기
', '.join(Pizza.objects.values_list('title', flat=True))
: 'cheese pizza, supreme pizza, bulgogi pizza'
```
Pizza 모델의 객체들을 전부 출력할 수 있고, value_list 쿼리셋을 이용하여 특정 이름의 속성값을 추출할 수 있다. 그리고 flat 옵션을 통해 리스트 형태로 얻을 수 있고, `', '.join`으로 문자열로 만들 수 있다.  


#### 자기자신을 참조하는 many-to-many

팔로워-팔로잉의 관계를 생각해보자. 

사람1이 사람2를 팔로우한다.  
사람2를 팔로우하는 사람은 사람1이다. 
사람1과 사람2는 User라는 공통속성이 있다. 

```python
class User(models.Model):
	followings = models.ManyToManyField(
    	'self',
        related_name='follower_set',
        symmetrical=False,
    )
```
예제를 통해 확인하자  

```python
사람1 = User.objects.create(name='사람1')
사람2 = User.objects.create(name='사람2')
```

User 모델의 객체로 사람1, 사람2를 생성한다. 

```python
사람1.following.add(사람2)
```
사람1이 사람2를 팔로잉한다. 

```python
사람1.followings.all()
<QuerySet [<User: 사람2>]>
```
사람1이 팔로잉하고 있는 정보. 

```python
사람2.followings.all()
<QuerySet []>
```
사람2가 팔로잉하고 있는 정보. 사람2는 사람1을 팔로잉하고 있지 않기 때문에 아무정보도 나오지 않아야 정상이다. 

> **symmetrical=False**  
> 사람2.followings.all()의 정보가 아무것도 나오지 않는 것은 symmetrical 속성을 지정해주었기 때문이다. True일 경우 한쪽에서 팔로잉해도 다른 쪽에서도 팔로잉으로 지정된다. 

```python
사람1.follower_set.all()
<QuerySet []>
```
symmetrical 속성 때문에 양방향으로 한번에 설정되지 않는다. 사람2가 사람1을 팔로잉하지 않았기 때문에 아무런 정보가 나오지 않는다. 

```python
사람2.follower_set.all()
<QuerySet [<User: u1>]>
```
사람2를 팔로잉하고 있는 사람에 대한 정보.

-

### Many-to-Many w/ through

아이돌과 그룹의 관계를 

```python
class User(models.Model):
	friends = models.ManyToManyField(
    	'self',
    	through='UserFriendsInfo',
    	through_fields=('from_user', 'to_user')
	)
	name = models.CharField(max_length=50)
```

```python
class UserFriendsInfo(models.Model):
    from_user = models.ForeignKey(
        User,
        related_name='+',
    )
    to_user = models.ForeignKey(
        User,
        related_name='+',
    )
    # 중개인이라는 User ForeignKey가 추가로 존재할경우,
    # 중간자모델을 사용하는 곳에서 through_fields 를 정의해야함
    recommender = models.ForeignKey(
        User,
        null=True,
        blank=True,
        related_name='recommender_userfriendsinfo_set'
    )
    when = models.DateTimeField(auto_now_add=True)
```
UserFriendsIndo라는 모델에 보면 from_user와 to_user가 동시에 ForeignKey로 User를 참조하고 있다. User에서 


```


-

- One-to-one relationships   
: 일대일 관계, 건물과 주소의 관계이다.  


다른 앱의 모델을 직접 import해서 relationship을 맺을 수 있다. 

-

### Field name restrictions
필드 네이밍을 할 때 예약어는 사용할 수 없다. 그리고 underscore가 연속으로 두번 들어간 경우도 허용되지 않는다. 

-

### Meta options

```python
class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"
```
클래스 내부에 위와 같이 class Meta를 설정할 수 있다. meta data는 필드가 아닌 모든 것에 해당된다. 



--------


```
In [18]: Person.objects.values_list()
Out[18]: <QuerySet [(1, 'youngmin', 'L', 'South Korea'), (2, 'minsung', 'M', 'South Korea')]>

In [13]: Person.objects.values_list('name')
Out[13]: <QuerySet [('youngmin,','minsung',)]>

In [17]: Person.objects.values_list('name', flat='True')
Out[17]: <QuerySet ['youngmin', 'minsung']>


```

on_delete=models.CASCADE 제거할 때 같이 사라짐
on_delete=models.

related_name 은 역참조. 강사인 사람이 다시 자신을 호출할 때?? 
강사 입장에서 person_set을 찾는거 보다 student_set이라고 해서 더 직관적으로 표현

self로 지정된 Foreign Key가 두개이상이면 서로 같은 역참조 이름을 가지기 때문에 에러가 발생한다. 각각의 related_name을 다르게 지정해야한다. 

group은 2개를 초과한 foreign key가 있을 때 명시적으로 지정해준다. 

